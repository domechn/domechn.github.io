


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  ArgoCD Monorepo 性能优化之路 |    Domechn.</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="/favicon.png" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Not Bad" type="application/atom+xml">
</head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          Domechn.
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              HOME
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
          <a href="/mypages/footprints" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              FOOTPRINTS
            </li>
          </a>
        
          <a href="/atom.xml" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              RSS
            </li>
          </a>
        
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        Domechn.
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>HOME</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
    <a href="/mypages/footprints" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>FOOTPRINTS</span>
      </div>
    </a>
  
    <a href="/atom.xml" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>RSS</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">ArgoCD Monorepo 性能优化之路</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Aug 03 2024</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <blockquote>
<p>本文中 ArgoCD 为 2.8.x 版本。</p>
</blockquote>
<p>在这篇博客中，我将分享我们在使用 ArgoCD 和 Monorepo 的过程中遇到的性能问题以及我们是如何解决这些问题的，最终实现在 ArgoCD 中使用一个 Monorepo 稳定部署超过 100k+ 应用的。</p>
<h2 id="为什么使用-Monorepo"><a href="#为什么使用-Monorepo" class="headerlink" title="为什么使用 Monorepo"></a>为什么使用 Monorepo</h2><h3 id="通过目录结构划分环境和集群，方便权限控制"><a href="#通过目录结构划分环境和集群，方便权限控制" class="headerlink" title="通过目录结构划分环境和集群，方便权限控制"></a>通过目录结构划分环境和集群，方便权限控制</h3><p>通过 Prow 和 OWNERS 文件，只有特定的人或 team 能 <code>/lgtm</code> 合并特定 <code>业务/环境/集群/应用</code> 的变更 PR。</p>
<h3 id="方便批量变更"><a href="#方便批量变更" class="headerlink" title="方便批量变更"></a>方便批量变更</h3><p>因为所有部署文件都在一个仓库中，当有新的 feature 需要 enable 时，可以通过脚本批量更新所有部署文件。</p>
<h3 id="方便新环境，新集群上线"><a href="#方便新环境，新集群上线" class="headerlink" title="方便新环境，新集群上线"></a>方便新环境，新集群上线</h3><p>有新环境或新集群需要上线时，批量拷贝文件夹并替换全局变量即可同步所有 infra 组件&#x2F;应用 到新集群。</p>
<h3 id="当前用法"><a href="#当前用法" class="headerlink" title="当前用法"></a>当前用法</h3><p>因业务需要，我们会在每个业务的账号中部署一套 ArgoCD，因此有多个 ArgoCD 集群。不过 98% 以上的应用使用同一个 Monorepo。</p>
<p>以下是常用的几个 ArgoCD 集群以及用量。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/images/argocd_monorepo/argo-cd-1.png" >
        </sapn>
      <br>
        <span class="lazyload-img-span">
        <img   
           data-src="/images/argocd_monorepo/argo-cd-2.png" >
        </sapn>
      <br>
        <span class="lazyload-img-span">
        <img   
           data-src="/images/argocd_monorepo/argo-cd-3.png" >
        </sapn>
      </p>
<h4 id="然后通过-Apps-of-App-模式部署应用"><a href="#然后通过-Apps-of-App-模式部署应用" class="headerlink" title="然后通过 Apps of App 模式部署应用"></a>然后通过 Apps of App 模式部署应用</h4><p>在 ArgoCD 中用一个 Global Application 去创建各个控制部署资源的 Application，再由这些 Application 去创建部署资源（Deployment，Service 等）。</p>
<h4 id="目前我们只使用了-Application"><a href="#目前我们只使用了-Application" class="headerlink" title="目前我们只使用了 Application"></a>目前我们只使用了 Application</h4><p>虽然我们也需要将一份配置同时部署到多个集群，但我们没有使用 ApplicationSet。如果是镜像集群，我们会修改镜像集群中 Application 的 source，直接指向主集群的 gitops 目录。</p>
<p>如果是灾备集群，它会有单独的配置，在上游的发布系统中，发布某个服务的主集群时，会一同修改这个集群里的配置。</p>
<hr>
<p>但是众所周知，ArgoCD 对 Monorepo 的支持非常差。我们做了很多努力来优化它的性能，使其能够满足我们的性能和稳定性要求。</p>
<h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2><p>我们通过以下几个方面来优化 ArgoCD 的性能。</p>
<h3 id="Monorepo-层面"><a href="#Monorepo-层面" class="headerlink" title="Monorepo 层面"></a>Monorepo 层面</h3><ul>
<li><strong>减少 Monorepo 体积</strong>：只存放部署文件。</li>
<li><strong>定时清理 Git 的 commit 记录</strong>：每次发版会创建一个 commit，当 commit 数量太多时，会严重增大 repo 的大小，导致 repo server 拉取速度变慢。我们会在 repo commits 数量超过 1M 时，备份 repo，然后清空 commit 记录。</li>
</ul>
<h3 id="ArgoCD-层面"><a href="#ArgoCD-层面" class="headerlink" title="ArgoCD 层面"></a>ArgoCD 层面</h3><ul>
<li><p><strong>增加 repo server 节点，关闭 repo server 的 HPA</strong>：</p>
<p>每次 ArgoCD <code>refresh</code> 或 <code>sync</code> 应用时都会请求 repo server 获取 <code>helm/kustomize</code> 渲染后的 K8s YAML 文件。由于每个 repo server pod 对同一个 repo 一次只能处理一个请求，而我们使用的是 mono repo（只有一个 repo），因此 repo server 的数量限制了 ArgoCD 的 sync 并发数。增加 repo server 的数量可以明显提高发版高峰期的 sync 效率。</p>
<p>但是，repo server 每次启动时会全量 clone repo（以我们现在的 mono repo 为例，有 40 万个 commits，虽然代码只占 150M，但仓库总大小超过 4Gi，全量克隆一次需要花费 3-4 min）。如果触发 HPA 导致 repo server 频繁扩缩容，反而会影响 sync 性能。因此，我们通常会为 repo server 配置足够的 replicas 以应对日常发版需求。当需要批量变更应用时，再手动扩容 repo server。</p>
</li>
<li><p><strong>关闭 auto refresh，将 appResyncPeriod 设置成 0</strong>：</p>
<p>我们关闭了所有 Applications 的 auto sync，以避免 ArgoCD 大量主动 refresh + sync Application，导致各个组件压力过大，无法处理正常用户的同步请求。</p>
<p>将 <a target="_blank" rel="noopener" href="https://argo-cd.readthedocs.io/en/stable/faq/#how-often-does-argo-cd-check-for-changes-to-my-git-or-helm-repository">appResyncPeriod</a> 设置为 0 意味着 application controller 不会主动请求 refresh Application，从而减轻各个组件的压力，这对性能优化也非常重要。</p>
</li>
</ul>
<h4 id="关闭-auto-sync-后，如何在-commit-之后触发-Application-的-sync-呢-？"><a href="#关闭-auto-sync-后，如何在-commit-之后触发-Application-的-sync-呢-？" class="headerlink" title="关闭 auto sync 后，如何在 commit 之后触发 Application 的 sync 呢 ？"></a>关闭 auto sync 后，如何在 commit 之后触发 Application 的 sync 呢 ？</h4><p>我们使用 <code>GitHub Action Workflow</code> 来监听文件变动，然后找到对应的 Application 并触发相应的 sync.</p>
<p>这得益于目录结构的规划，使我们能很方便的解析出变动文件对应的 Application。</p>
<p>目录结构如下:</p>
<pre><code class="markdown">├── app|infra # 分别对于业务应用和 infra 组件
│ ├── $project # 所属的项目
│ │ ├── $env # 所属的环境
│ │ | |-- $cluster # 所在的集群
│ │ | | |-- kustomize|helm # 使用的 argocd plugin
│ │ | | | |-- $app # app 名称
│ │ | | | | |-- values.yaml # 具体的配置文件
│ │ | | | | |-- application.yaml # 用于生成这个 app 的 argo Applications
</code></pre>
<p><strong>Github Action Workflow 的执行步骤</strong>:</p>
<ol>
<li>解析 commit 中变动的文件，找出变动的 应用类型 (app or infra), project, env, cluster，根据这些信息找到这个集群的 Global Application。</li>
<li>Sync Global Application。因为应用的 Application 会存储一些信息，需要先把应用的 Application 的 spec 同步上。</li>
<li>通过 <code>argocd app sync $app</code> sync 具体应用的 Application。</li>
</ol>
<p>这里还存在一个问题，即 Global Application 会管理大量的应用（可能有几千个）。这会导致同步 Global Application 非常慢。此外，当多个用户在同一个集群内同时发布应用时，所有人都需要同步这个 Global Application，必然会造成拥堵，导致大家都在这一步等待。</p>
<p>因此我们将这一步也进行了优化。</p>
<p>我们更改了 Global Application 的 sync 方式，不通过 argocd app sync，而是直接执行 kubectl apply。</p>
<p>在 GitHub Action Workflow 中，我们会先找到发生变动的应用。然后直接渲染出它的所有 Application（一般有多个，因为一个应用可能有多个 overlays）。接着，从 ArgoCD 所在的 Kubernetes 集群中列出这个应用的所有 Applications，并进行差异比较，找出不一样的 Applications，执行 <code>kubectl apply</code>。这样相当于变相刷新了 Global Application。</p>
<p>流程图如下：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="/images/argocd_monorepo/argo-cd-workflow.jpg" >
        </sapn>
      </p>
<p>经过上述优化后，我们能做到当一个 argocd 管理同一个 repo 中接近 7k 应用时，用户的发版也能在 30-50s 完成。（其中 sync global app 10s 左右，argocd sync app 在 15-35s 左右）<br>而且不会影响各个用户之间的发版。</p>
<h4 id="但是仍然存在影响-argocd-稳定性的问题"><a href="#但是仍然存在影响-argocd-稳定性的问题" class="headerlink" title="但是仍然存在影响 argocd 稳定性的问题"></a>但是仍然存在影响 argocd 稳定性的问题</h4><p>在完成上述的性能优化后，尽管 argocd 已经能满足业务发版的要求，绝大多数情况下，发版的速度都能满足业务的要求。但不幸的是，仍然存在一些会引起 argocd 抖动的问题。</p>
<p>在业务 Kubernetes 集群内资源变动时，ArgoCD 会对资源所属的 Applications 进行刷新。刷新过程中，controller 会检查缓存，如果缓存存在则结束处理；如果缓存不存在，则会请求 repo server 重新渲染资源。大多数情况下，刷新 Applications 会命中缓存，但在一些极端情况下，可能无法命中缓存，从而导致请求 fallback 到 repo server。由于 repo server 渲染资源非常耗时且占用大量 CPU，当大量渲染请求涌向 repo server 时，会导致其 CPU 被占满，甚至出现 OOM 情况，进而导致正常的同步请求无法处理，用户发布超时。可能造成这问题的原因包括：</p>
<ol>
<li>当业务 DevOps 批量操作集群内数据时，例如批量重启 deployments，ArgoCD 监听到 deployments 被修改或者 pods 被删除&#x2F;创建时，会找到相应的 Applications 并进行刷新。这会导致短时间内大量的 applications 被刷新。</li>
<li>当 DevOps 升级业务集群时，由于需要替换 nodes，这将导致大量 pods 被重建，进而致短时间内大量的 Applications 被刷新。</li>
<li>一些经常被 operators 更新的 CRD 也会触发 Applications 刷新。例如，KEDA 会频繁更改 HPA 的 spec，导致 Applications 被频繁刷新。</li>
</ol>
<p><strong>优化的方法</strong></p>
<p>argocd 2.8 之后提供了参数，可以忽略掉集群内一些资源的特定字段的监听：</p>
<pre><code class="yaml"># argo-cd helm values.yaml

# 比如这里配置了所有资源的 `.status` 和 `.metadata.resourceVersion` 的变更，都不会触发 argocd refresh
server:
  config:
    resource.customizations.ignoreResourceUpdates.all: |
      jsonPointers:
      - /status
      - /metadata/resourceVersion
</code></pre>
<p>但这样仍然不能完全解决问题，因为总有些漏网之鱼，比如新部署了一个 operator 会频繁修改它的 CRD spec 之类的。因此，我们还需要想其他办法来根治这个问题。</p>
<p>然后我们想到，因为我们禁用了所有 Applications 的 auto sync，所以其实这个监听资源变动 + refresh Application 的机制，对我们来说可有可无。</p>
<p>因此我们魔改了 argocd controller 的代码：</p>
<p>如果这个监听到资源的变动，但是这个资源所属的 application 没有开启 auto sync 或者没有正在被操作（正在被手动 sync 中），那么就不 refresh Application。</p>
<p>至此这个问题，才被彻底解决。</p>
<p>改动的 PR:</p>
<p><a target="_blank" rel="noopener" href="https://github.com/domechn/argo-cd/pull/1">Improve performance for refreshing apps by domechn · Pull Request #1 · domechn&#x2F;argo-cd (github.com)</a></p>
<hr>
<p><strong>除此之外还要保证 repo server 不会因为短时间大量请求被打到 OOM</strong></p>
<p>首先 repo server OOM 必然导致当前正在处理的 argocd sync 请求失败，其次因为 repo server 重启后要重新拉代码，会很大延长下次 argocd sync 的时间，影响发版稳定性。</p>
<p>不过 argocd 提供了 <code>reposerver.parallelism.limit</code> 这个参数，可以限制 repo server 同一时间并发处理渲染请求的数量。这个值是一个经验值，可能要根据 mono repo 大小和 repo server pod resource 来调整。以我们自己的经验来看，我们的 repo 在 4G 左右，repo server resource limit 给的是 12Gi4vCPU, sidecar plugin 是 6Gi4vCPU，那么它设置成 15，repo server 几乎就不会被打到 OOM。</p>
<br/>

<p>这样一番优化完后，argocd 的性能表现终于变得稳定，几乎很少有抖动，而且理论上之后性能也不会太受到 application 数量增长的影响（也行还会有，但目前没发现）</p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            <ol class="space-toc"><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Monorepo"><span class="space-toc-text">为什么使用 Monorepo</span></a></li><li class="space-toc-item space-toc-level-2"><a class="space-toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="space-toc-text">优化策略</span></a></li></ol>
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Hexo</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/domechn" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:domdoumc@gmail.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>
